import { c as create_ssr_component, e as escape } from "./ssr.js";
import { C as Contents } from "./2-system-design-tools2.js";
const _2_system_design_tools = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const contents = Contents;
  if ($$props.contents === void 0 && $$bindings.contents && contents !== void 0)
    $$bindings.contents(contents);
  return `<h1>${escape(Contents.title)}</h1> <p>${escape(contents.subtitle)}</p> <h2 data-svelte-h="svelte-1j1kxdd"><a href="#intro">Introduction</a><span id="intro"></span></h2> <p data-svelte-h="svelte-1lkusy">In the last part, I’ve established why system design is important and why it’s not an exam, but rather a brainstorming. Furthermore, I’ve
noted that there is no correct answer to system design questions without getting more context from the interviewee.</p> <p data-svelte-h="svelte-63j439">Before getting to specific tasks and how to approach them, I’d first like to establish what tools we have at our disposal. All images in this
part are taken in some shape or form from the book I’ve added in references.</p> <h2 data-svelte-h="svelte-1c8q4pf"><a href="#basic-complex-system">Basic vs Complex System</a><span id="basic-complex-system"></span></h2> <p data-svelte-h="svelte-jnfdly">So, the most basic system we can get is quite simple. It has a client, it has a web server, and it’s accessible. It can look like this:</p> <img src="/images/system-design/single-server-setup.png" alt="Single Server Setup" title="Single Server Setup" class="image" loading="lazy"> <p data-svelte-h="svelte-s2jfx1">This is how probably most frontend developers view this setup</p> <ul data-svelte-h="svelte-2bcy5a"><li>We have a web or mobile app deployed on an IP address using DNS, using DNS to map it to human readable name</li> <li>We have a server deployed on an IP address, using DNS to map it to human readable name</li> <li>Frontend communicates with the backend using HTTP calls to its address</li></ul> <p data-svelte-h="svelte-zbjm2p">Now, this is a valid approach - I do the same for this blog page. Sure, there may be some magic by Netlify where it is deployed, but that’s
about it. I didn’t create anything else.</p> <p data-svelte-h="svelte-1imetc5">Now, let’s take a look at a complex system:</p> <img src="/images/system-design/complex-system-design.webp" alt="Complex System Design" title="Complex System Design" class="image" loading="lazy"> <p data-svelte-h="svelte-1qs4jeo">Well, now we’re talking! This is the last image from System Design Interview book in chapter Scale From Zero to Millions of Users.
I’ve also previously said that frontend developers often view the setup differently. If you take a look at the design, it’s because the
only thing that changed for the frontend is CDN for static content. Other than that, you still call the same endpoints - it’s just handled differently
behind the url.</p> <p data-svelte-h="svelte-ftymq0">Alex Xu approached this in a way that additional bits and pieces on it. If I were to do the same, I could just copy the book contents.
I’ll try to approach this from a different standpoint. This is A complex system design, not THE complex. It’s not the best for all complex software.</p> <p data-svelte-h="svelte-wopoml">So, what I’m gonna do in the next parts is I’m gonna always come back to this image. I’ll try to specify a business case that would trigger
the need for having the web server complex.</p> <h2 data-svelte-h="svelte-eibm5w"><a href="#intermezzo">Intermezzo</a><span id="intermezzo"></span></h2> <p data-svelte-h="svelte-foueu9">Before I continue, I’d like to say one thing. I forgot it. Nevermind.</p> <h2 data-svelte-h="svelte-p9lwr8"><a href="#cdn">CDN - Content Delivery Network</a><span id="cdn"></span></h2> <p data-svelte-h="svelte-rxaxvf">Let’s start from the top. Content Delivery Network, or CDN for short, is a group of servers that serve content close to end users.</p> <p data-svelte-h="svelte-19ktr0v">In simple words - If I’m in Czechia and log in to Facebook, I’m likely to get content from CDN. Imagine you have a server in the US and
send data to Europe. The data would have to move thousands of kilometres. But, what if you could have a server in Europe? Then it’d be just hundreds.</p> <p data-svelte-h="svelte-1yo7ft2">That’s exactly what CDN is. Multiple servers that send content to the end user. If I’m in the US, I get data from US. If I’m in Europe, I get it from Europe.
CDNs typically have multiple servers per continent (regions). If you have users in multiple regions, this is something you won’t be wrong about doing.</p> <p data-svelte-h="svelte-1lkvcnc">CDN is one of two things that if you want to know if you should use it, the answer is always an easy yes or no. If you have static content that can be cached:</p> <ul data-svelte-h="svelte-15e77wv"><li>You have users in multiple regions -&gt; You want a CDN</li> <li>You have users in single country -&gt; You want a server in that country</li></ul> <h2 data-svelte-h="svelte-1q1eclx"><a href="#web-servers">Web Servers</a><span id="web-servers"></span></h2> <p data-svelte-h="svelte-edhqxd">Even though load balancer is second thing from the top, it’s impossible to talk about it before understanding web servers.</p> <p data-svelte-h="svelte-1upzkbx">Web server is just a computer that has your code and runs it. Whenever you do an API call to <a href="https://rickandmortyapi.com/" rel="nofollow">Rick and Morty API</a>,
there will be some code like this:</p> <pre class="language-js"><!-- HTML_TAG_START -->${`<code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getDataFromDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1h69a5v">So, the data is stored in a database. And this code is called on a server. Imagine you have only one web server and 10 users:</p> <ul data-svelte-h="svelte-cp8n1d"><li>An HTTP call is done to the web server</li> <li>The code above is executed</li> <li>While the DB data are still being fetched (line 2), another request may already be processed by the web server</li></ul> <p data-svelte-h="svelte-1jkz87c">You can have 1 webserver to 10 DB calls simultaneously. The database and web server are separate (might even be on separate servers).</p> <p data-svelte-h="svelte-12q958z">So, let’s imagine your server is a little more complex. Rather than just fetching data from database, it does a complex operation:</p> <pre class="language-js"><!-- HTML_TAG_START -->${`<code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">performSomeOperationTakingTenSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getDataFromDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1nh2isv">If you have this code on the server, when 10 users make a call to the server, the server will:</p> <ul data-svelte-h="svelte-14795i1"><li>take the first request, starting to perform some operation taking 10 seconds</li> <li>take the second request, but the first request hasn’t been finished due to long operation. It will be put in queue</li> <li>repeat for all 10 requests</li></ul> <p data-svelte-h="svelte-1pbo93c">So, to serve 10 users, it might take 100 seconds to serve them all - or 10 seconds for first, 20 seconds for second, …</p> <p data-svelte-h="svelte-bdbzxf">In come multiple servers:</p> <ul data-svelte-h="svelte-48gqak"><li>We can have the same code deployed on multiple servers</li> <li>By having 2 servers, we’ll reduce the time to 50 seconds, by having 10 servers, 10 seconds to handle all requests.</li> <li>Each call will be handled by the same endpoint, but not the same server.</li></ul> <blockquote data-svelte-h="svelte-1e597i7"><p>Consideration: As you can see, having 2 servers instead of 1 makes it half, but having 10 servers makes it tenth. There are diminishing returns when adding servers,
but there are costs to consider. You need to consider the pros and cons of having multiple servers (and the amount of them) for your specific business case.</p></blockquote> <blockquote data-svelte-h="svelte-1kmmb26"><p>Consideration: You can see terms used as “Vertical” and “Horizontal” scaling. This is an important thing to consider as well.
If you have an operation that takes 10 seconds to process, you can make your single server more performant to handle it in 1 second.<br>
You don’t need multiple servers to speed it up.</p></blockquote> <blockquote data-svelte-h="svelte-nbcdz8"><p>Consideration: Multiple servers allow for redundancy. If one server falls down, the others can take the load, although they may be slower.</p></blockquote> <h2 data-svelte-h="svelte-1yruzrd"><a href="#load-balancer">Load Balancer</a><span id="load-balancer"></span></h2> <p data-svelte-h="svelte-i3ksrj">Now that we’ve established that we can have multiple servers and what their benefit is, what happens? Consider that we don’t do anything except get 10 servers:</p> <ul data-svelte-h="svelte-cz0i88"><li>The frontend hits API</li> <li>The API performs some code on server</li> <li>What server?</li></ul> <p data-svelte-h="svelte-lvlviu">That last point is important - what server? We have just created 10 servers. They exist. But most likely, only one is still being hit.</p> <p data-svelte-h="svelte-2be8va">Here comes the load balancer into play. It’s a tool that “balances the load”. Or, in other words - if load balancer sees an incoming request,
it’ll check if there are servers that are lesser used. If there are, it will route the request to the server that has the lowest load.</p> <p data-svelte-h="svelte-14bwpks">Load balancer is very closely tied to multiple servers. If you have just one server, there is nothing load balancer can do - there are no other servers
it can route the requests to, so it will keep hitting the same one. However, if you have more, servers, you will have to use a load balancer.</p> <p data-svelte-h="svelte-1bzv7k0">Same as with CDN, the question “Do I want a load balancer” has a very straightforward answer</p> <ul data-svelte-h="svelte-17wia0w"><li>You have multiple servers -&gt; You <strong>need</strong> a load balancer</li> <li>You have one server -&gt; Load balancer is useless</li></ul> <h2 data-svelte-h="svelte-1kgbwxq">Refresher</h2> <p data-svelte-h="svelte-w6vxgk">At this point, we’ve gone through CDN, load balancer and webservers. There are still a couple more categories to go through, so I’ve
added the image below so you don’t need to scroll all the way up.</p> <img src="/images/system-design/complex-system-design.webp" alt="Complex System Setup" title="Complex System Design" class="image" loading="lazy"> <h2 data-svelte-h="svelte-1pz3djp"><a href="#databases">Databases</a><span id="databases"></span></h2> <p data-svelte-h="svelte-1vmdjn6">Databases are among the hardest things to consider when dealing with system design and there are quite a few approaches.</p> <h3 data-svelte-h="svelte-11kf5fl"><a href="#what-db-to-use">What DB to use</a><span id="what-db-to-use"></span></h3> <p data-svelte-h="svelte-1u1zjw9">In general, there are 2 types of databases - relational, and non-relational.</p> <p data-svelte-h="svelte-ofvm1f">Relational databases (or Relational Database Management Systems) are basically databases using SQL. Examples can be MySQL, PostgreSQL or Microsoft SQL Server.
These databases have been around for a long time and have proven record of working reliably.</p> <p data-svelte-h="svelte-18qw6d7">Non-relational databases are those that don’t store tables and rows, but rather collections of unstructured data.
<a href="https://www.youtube.com/watch?v=HdnDXsqiPYo" rel="nofollow">Webscale</a>, DynamoDB, Cassandra fall into this category.</p> <p data-svelte-h="svelte-10wug1q">In a big system, you might be inclined to use both - SQL for structured data, and NoSQL for unstructured data or storing massive amounts of them.</p> <h3 data-svelte-h="svelte-yj5gam"><a href="#single-database">Single Database</a><span id="single-database"></span></h3> <p data-svelte-h="svelte-766rl6">So, we’ve created a web application. We have a frontend, we have a server that defines the endpoints. Now, we need to store the data in case our server fails.</p> <p data-svelte-h="svelte-12p8bt2">To do that, we’ll choose a database that suits our needs. We put it up and done - our server is able to write data to DB.</p> <p data-svelte-h="svelte-nnsrpq">When the data is being read, it does so from the same database it writes to.</p> <p data-svelte-h="svelte-1bz78cc">Now, let’s imagine that:</p> <ul data-svelte-h="svelte-1nmkmrz"><li>We have a load balancer</li> <li>We have 10 servers</li> <li>We have a single database</li></ul> <p data-svelte-h="svelte-1vufb8f">We have 10 servers reading from the same database. Which is not a problem. What feels weird is that we are not consistent:</p> <ul data-svelte-h="svelte-11kqh2"><li>We have 10 servers</li> <li>If one of them dies, others can take care of the job</li> <li>What if our database breaks?</li></ul> <h3 data-svelte-h="svelte-jyymjc"><a href="#master-slave-database">Master/Slave Database</a><span id="master-slave-database"></span></h3> <p data-svelte-h="svelte-3xv927">To prevent the problem and come up with redundancy, we can set up multiple databases. However, here we may run into a problem:</p> <ul data-svelte-h="svelte-emqu53"><li>Let’s consider that we have 2 databases.</li> <li>Each performs write operations</li> <li>How does one DB know about the updates of the other one?</li></ul> <p data-svelte-h="svelte-1ef4az8">In comes the master/slave concept. With this case, we’ll have 2 types of databases:</p> <ul data-svelte-h="svelte-yjnc1e"><li>Master Database - Write</li> <li>Slave Database - Read</li></ul> <p data-svelte-h="svelte-3otln5">By doing so, we will have only one database that performs the write operations, and the data from master DB is <a href="https://www.fivetran.com/learn/database-replication" rel="nofollow">replicated</a>
to the slave databases. Most applications have way more reads to write (imagine how many facebook posts you read vs how many you create).</p> <p data-svelte-h="svelte-1x27x5v">Now, if something happens to the master database, simply make on of the slave databases the master one (= allow writing into DB). Therefore, your availability stays high.</p> <p data-svelte-h="svelte-7t4v3b">If something happens to all slave databases, the master database can still perform the read operations - although now it will be slower, it will still be available.</p> <p data-svelte-h="svelte-10u4pdz">So, in short:</p> <ul data-svelte-h="svelte-18hay76"><li>Master / Slave databases allow for redundancy and higher availability and performance</li> <li>When there are problems with databases, reroute the traffic or make slave databases the master</li> <li>When using multiple databases, you need to replicate the data across them.</li></ul> <p data-svelte-h="svelte-40g6xk">It may end up looking something like this:</p> <img src="/images/system-design/master-slave-db.webp" alt="Master Slave DB" title="Master Slave DB" class="image" loading="lazy"> <h3 data-svelte-h="svelte-zvx7qj"><a href="#master-slave-database">Sharding</a><span id="master-slave-database"></span></h3> <p data-svelte-h="svelte-rd89eh">In the example we’ve started with, you can see <a href="https://aws.amazon.com/what-is/database-sharding/" rel="nofollow">Database Shards</a>. So, let’s take a look at this fancy word.</p> <p data-svelte-h="svelte-2hu2qp">Database sharding is nothing more but having multiple databases. Or multiple multiple databases. Because we’ve already had multiple with Master / Slave, but each shard can have its own Master / Slave approach.</p> <p data-svelte-h="svelte-14l7d65">So, what exactly is it? Well, imagine that you have 5 rows in your database</p> <pre class="language-js"><!-- HTML_TAG_START -->${`<code class="language-js"><span class="token keyword">const</span> databaseRecords <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token string">"Simon"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token string">"Shymon"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token string">"Shymono"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token string">"Simone"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token string">"Siminion"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1kii2u9">Now, you could store these records in one DB, or in multiple. You could have for example 5 databases, each holding 1 record.</p> <p data-svelte-h="svelte-12u664c">Why is that good? Well, imagine that your business has tens of millions of rows. The data is so large that it’s getting slow to handle it.</p> <p data-svelte-h="svelte-bjlcag">So what you can do is instead of having one database system with tens of millions of rows, you can have tens of shards with millions of rows.</p> <p data-svelte-h="svelte-1we891u">Every time your database data is called, you will retrieve it from a different shard. And, if set up properly, you will be fetching records from millions of rows, rather than multiples of it.</p> <p data-svelte-h="svelte-mbhwto">So how do you achieve that? Well, ignoring the specifics of setting it up, you need to know which shard to save to, and which shard to retrieve data from.
To do that, you’ll often see the term <code>Shard key</code>. This key is used to define to which DB you will save.</p> <p data-svelte-h="svelte-jzsgj">Consider that the <code>Shard key</code> is the first letter of the name. Now, with the example above, even if we had 20 shards, we would still save all the records to one.
There is no ideal shard key, but it is something that must be considered in order to get evenly sharded databases and we can use them to full.</p> <blockquote data-svelte-h="svelte-vfp3a1"><p>Consideration: You can have your shards by location. In that way, you can also have shards closer to the users. Imagine that you have users from Paris and the US.
You can have one shard in Paris and one in the US, and save data closer to the user, making it faster.</p></blockquote> <p data-svelte-h="svelte-zsqb0d">So, in short, shard is basically a database system that is part of a larger database system - that of the whole company.</p> <p data-svelte-h="svelte-m1jc2g">Sharding is generally the hardest to design because:</p> <ul data-svelte-h="svelte-u95vig"><li>Uneven distribution of data (one shard contains more data than all the other shards due to bad <code>Shard key</code>)</li> <li>Costs (This means a lot of physical databases)</li> <li>Complexity (Developers are likely to manually manage the database. Furthermore, they don’t manage one, but many)</li></ul> <h2 data-svelte-h="svelte-1qdqato"><a href="#database-summary">Database Summary</a><span id="database-summary"></span></h2> <p data-svelte-h="svelte-1skz2jh">Databases seems like awful lot to take in. But, in short:</p> <ul data-svelte-h="svelte-1fgwbl"><li>Choose database that you feel will be good for your needs<ul><li>You can use either SQL or NoSQL, or both!</li></ul></li> <li>Choose the database management for your needs<ul><li>Single database, Master/Slave database, sharding</li></ul></li> <li>Consider the costs<ul><li>If you have single database, you will most likely have to scale up computing power. When you have multiple, you add additional servers.</li></ul></li> <li>Consider redundancy<ul><li>With single database, you also have a single point of failure</li></ul></li></ul> <h2 data-svelte-h="svelte-1raj55u"><a href="#caching">Caching</a><span id="caching"></span></h2> <p data-svelte-h="svelte-134elyd">Caching is a really simple concept. Consider the following code:</p> <pre class="language-js"><!-- HTML_TAG_START -->${`<code class="language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">getData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> datum <span class="token operator">=</span> <span class="token function">getDatumFromDatabase</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> datum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1lzci8j">This is one of the simplest form of caching. Whenever you call a database, the result is saved in memory. When the DB is queried again,
you already will have the answer in memory and can return it right away.</p> <p data-svelte-h="svelte-yup2gx">Naturally, this can be dangerous. But it gives an idea of a simple cache. Now, what other cache options do we have in system design?</p> <p data-svelte-h="svelte-2396sq">The first thing described is already cache. CDN is a cache. When it is fetched by the first user, it’s fetched with latest data. So, if
an image hasn’t been fetched yet from the CDN, it is loaded into the CDN. The next time the resource is requested, it is returned from cache.
You can actually see this if you’ll ever deploy on netlify. Whenever you push new code and load the page,
it takes a little longer to load for you the first time you refresh it.</p> <p data-svelte-h="svelte-wp78qe">Similarly, you can cache the data you return from backend in the local storage. If it doesn’t change often, you can retrieve it from local storage
without calling the server ever again after you loaded the page once.</p> <p data-svelte-h="svelte-1cmmgui">So, what other caching options do we have except between backend and frontend? Well, let’s not view this as backend and frontend. Let’s view this as processes.</p> <p data-svelte-h="svelte-i1j67o">As mentioned before, a database can be a program running on some computer. It can be the same computer your backend is on. Or it can be a different one.</p> <p data-svelte-h="svelte-1co8k3x">If it is the same computer, it is a process on a different port than your web server. So, your web server must request data from it.</p> <p data-svelte-h="svelte-17t46p5">Let’s take a look at the whole picture:</p> <ul data-svelte-h="svelte-1d2nlmg"><li>A frontend is a process that runs on one computer</li> <li>cache between FE and BE (CDN)<ul><li>or: cache between process 1 and process 2 (CDN)</li></ul></li> <li>A backend is a process that runs on another computer</li> <li>Database</li></ul> <p data-svelte-h="svelte-170vm82">See what I did there? We made a cache between 2 processes. We can do the same between backend and database!</p> <p data-svelte-h="svelte-y6zxp8">There are a bunch of caches, for examples Redis or Memcached. These are also called “in memory storage” if you search for them.</p> <p data-svelte-h="svelte-1c1h36q">What they basically do is that when you query a database, the result is saved into a cache (similarly with the JS code above). Whenever the DB
is queried again, it is retrieved from the cache instead.</p> <blockquote data-svelte-h="svelte-1mn4trr"><p>Consideration: Caches are faster, but they do not reflect the real state. If your data is modified often and your data needs to be up to date,
it may not be the best choice</p></blockquote> <blockquote data-svelte-h="svelte-o8oe0s"><p>Note: We’re entering to a territory that we can cache between FE and BE, and BE and Database. These terms are getting outdated.<br>
The reason for that is that we can have multiple backends (or services). Each of the services can have their own database, and
the services can communicate with one another. You can cache between these as well.</p></blockquote> <h2 data-svelte-h="svelte-1kgbwxq">Refresher</h2> <p data-svelte-h="svelte-9h9ei4">The last things that are left are message queue and workers. I’m adding the image below to see how far we’ve progressed.</p> <p data-svelte-h="svelte-kymb8l">Furthermore, I’d like to change/clarify the terms I’ve been using:</p> <ul data-svelte-h="svelte-1mi6u1p"><li>Frontend -&gt; Frontend (A process that runs on the user’s machine)</li> <li>Backend -&gt; Backend for Frontend (A process that directly communicates with the frontend)</li> <li>Service (or Worker) -&gt; Any additional service. This service can have it’s own database and can be completely separated</li> <li>Database -&gt; Database (A process that writes and reads data)</li></ul> <img src="/images/system-design/complex-system-design.webp" alt="Complex System Setup" title="Complex System Design" class="image" loading="lazy"> <h2 data-svelte-h="svelte-1l80rwx"><a href="#msg-queue-and-workers">Message Queue and Workers</a><span id="msg-queue-and-workers"></span></h2> <p data-svelte-h="svelte-1xh4sy">We’re slowly getting to the end of this. The last two parts are Message Queue and Workers. Similarly to load balancer, message queue doesn’t make much sense without workers, so let’s deal with those first.</p> <h3 data-svelte-h="svelte-19lavz8"><a href="#workers">Workers</a><span id="workers"></span></h3> <p data-svelte-h="svelte-1shiakj">Workers are basically services having their own code, just like our backend. We could easily have the services as part of our BFF directly.</p> <p data-svelte-h="svelte-1g8wgaa">However, the difference is more of their usage. Imagine, if you will, that there’s a image processing that takes an hour to finish. Your BFF does
way more than image processing, but it is one of the core features. This one feature could single handedly slow your entire business down. So,
you will move it away from your system.</p> <p data-svelte-h="svelte-1hkp0j7">And that’s basically it. A Worker is a dedicated piece of code that is separated from your web server so that it can do its own thing while your backend is unaffected in terms of performance.</p> <p data-svelte-h="svelte-1pie0so">One thing to consider here is that a separate service can have:</p> <ul data-svelte-h="svelte-1mc6tq8"><li>its own load balancer</li> <li>its own cache</li> <li>its own database</li></ul> <p data-svelte-h="svelte-jnljrv">So, you can get into a point where you start designing a single worker just as much as you designed the original system.</p> <h3 data-svelte-h="svelte-d3zwun"><a href="#msg-queue">Message Queue</a><span id="msg-queue"></span></h3> <p data-svelte-h="svelte-1pt2zyx">I’ve mentioned with workers that they can have their own load balancer, cache and database. However, chances are you don’t want to retrieve
the data right away from the <code>Worker</code> when you request it because you know it takes time. So, what you do is:</p> <ul data-svelte-h="svelte-98pd4p"><li>You put the things you want to get done in a queue in <code>BFF</code></li> <li>You make this queue available to the <code>Worker</code></li> <li>The <code>Worker</code> is listening to the queue and performs operations on it</li></ul> <p data-svelte-h="svelte-1kgeldr">Here, different terms are used:</p> <ul data-svelte-h="svelte-1x4u0iw"><li>The <code>BFF</code> would be called <code>Producer</code> because it <code>produces</code> the request to perform something.</li> <li>The <code>Worker</code> would be called the <code>Consumer</code> because it <code>consumes</code> the request from <code>producer</code> and acts upon it.</li> <li>The middleware between these two (that takes from <code>Producer</code> and makes it available to <code>Consumer</code>) is the MessageQueue</li></ul> <p data-svelte-h="svelte-rlmix6">Now that it’s clear, let’s again reiterate on why this is a good concept:</p> <ul data-svelte-h="svelte-19474zp"><li>When there are many items in the queue, you can add more <code>Workers</code> so that they deal with it faster</li> <li>When there are no items, you can scale the workers back down because you don’t need them</li> <li>You can completely decouple the operations that take long time with your <code>BFF</code></li></ul> <h2 data-svelte-h="svelte-1gat2or"><a href="#summary">Summary</a><span id="summary"></span></h2> <p data-svelte-h="svelte-148xmyb">Let me put the image here one last time:</p> <img src="/images/system-design/complex-system-design.webp" alt="Complex System Setup" title="Complex System Design" class="image" loading="lazy"> <p data-svelte-h="svelte-xvbpvw">During this lengthy post, we’ve gone from a simple single web server to multiple web servers with a lot of redundancy and cache and performance gains.
These are most likely all the tools we will use in any system design task going further. We may use different algorithms, but we likely won’t go to additional tooling.</p> <p data-svelte-h="svelte-17ng467">What we didn’t cover is additional tooling. There are many ways to approach this, but:</p> <ul data-svelte-h="svelte-lljkp3"><li>Logging is basically information for developers to understand what the issue is and helps resolve it. Might be as simple as logging in the console.</li> <li>Monitoring is real-time view of what is currently happening on the server. This is important, because if we are alerted that our servers are 90% used, we may want to scale it up.</li> <li>Automation covers absolutely anything that we regularly do manually. This can be scaling of the running instances, running monitoring checks, but also deployments and CI/CD.</li> <li>Metrics are already in some form used in monitoring part, and they could be interchangable (RAM usage of servers for example). However, i used monitoring for
system monitoring. In the case of metrics, I’m talking about business metrics - daily users, revenue, how long user spends using the tool, and more.</li></ul> <p data-svelte-h="svelte-1a2djd9">A short bullet point I’d like to end up with is:</p> <ul data-svelte-h="svelte-h1eo6e"><li>We have many tools at our disposal</li> <li>If we use them wrong, it may be very costly</li> <li>There is no catch-all tool to solve all our problems. It will always be a compromise.</li></ul> <p data-svelte-h="svelte-7pmbj7">If you’d like to still speed up your application after doing all these changes, you can still:</p> <ul data-svelte-h="svelte-1kihqgd"><li>Completely decouple a time-consuming task to a separate service</li> <li>Add load balancing, own DB, caching to the separate service</li> <li>Set up connection</li></ul> <p data-svelte-h="svelte-1w7xkee">We can keep decoupling until every part of our system is a separate computer. But at that point, it’d be very hard to manage (and probably very costly).</p> <p data-svelte-h="svelte-1kqdu74">So, again - consider the pros and cons, and make a compromise of what is beneficial.</p> <h1 data-svelte-h="svelte-uqufyh"><a href="#references">References</a><span id="references"></span></h1> <ul data-svelte-h="svelte-127ioff"><li><a href="https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF" rel="nofollow">System Design Interview book</a></li> <li><a href="https://www.cloudflare.com/en-gb/learning/cdn/what-is-a-cdn/" rel="nofollow">What is CDN</a></li> <li><a href="https://www.fivetran.com/learn/database-replication" rel="nofollow">Database Replication</a></li> <li><a href="https://aws.amazon.com/what-is/database-sharding/" rel="nofollow">Database Shards</a></li></ul>`;
});
export {
  _2_system_design_tools as default
};
