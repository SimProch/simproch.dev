import { c as create_ssr_component, e as escape } from "./ssr.js";
import { C as Contents } from "./10-system-design-chat-service2.js";
const _10_system_design_chat_service = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const contents = Contents;
  if ($$props.contents === void 0 && $$bindings.contents && contents !== void 0)
    $$bindings.contents(contents);
  return `<h1>${escape(Contents.title)}</h1> <p>${escape(contents.subtitle)}</p> <h2 data-svelte-h="svelte-1j1kxdd"><a href="#intro">Introduction</a><span id="intro"></span></h2> <p data-svelte-h="svelte-1owhayo">Oh hello again! Nice to see you come by!</p> <p data-svelte-h="svelte-19i81dm">So far, we’ve gone through a lot of stuff. But at the same time, we still have a lot to learn!</p> <p data-svelte-h="svelte-1khdr3t">In the first chapters, I’ve mentioned that working with stateful requests is not scalable. But sometimes, you don’t
have a good choice.</p> <p data-svelte-h="svelte-18ma5x3">Now, I still stand by that point - stateful architecture is weird. But how would you create a chat service without one?
How would we be able to receive info from backend if the backend can’t push anything to us?</p> <p data-svelte-h="svelte-fn268l">Now, bear in mind this is different than notifications - those are using different tools than our own APP. SMS, email,
all of these are something different than simply receiving messages from the server.</p> <p data-svelte-h="svelte-1bursg6">So, how would we create a chat system?</p> <h2 data-svelte-h="svelte-7tpmo1"><a href="#requirements">Requirements</a><span id="requirements"></span></h2> <p data-svelte-h="svelte-17distg">We have quite a bunch of different chat apps. Furthermore, we have a bunch of different types of chats! Consider the following:</p> <ul data-svelte-h="svelte-czvzpt"><li>A facebook messenger where you chat 1-to-1 with your friend</li> <li>A discord chat room where you chat N-M with a lot of other people</li> <li>A combination of rooms &amp; direct messages</li></ul> <p data-svelte-h="svelte-rnfvzm">So, to know how to approach something, what are the requirements for this app? Let’s assume the following:</p> <ul data-svelte-h="svelte-1h307q2"><li>1-to-1 and group chat</li> <li>mobile &amp; web app</li> <li>50 millions daily active users</li> <li>online indicator is available</li> <li>Message has a size limit of 100 000 characters</li> <li>End to end encryption is supported</li> <li>The chat history should be stored forever</li></ul> <p data-svelte-h="svelte-wwagkx">So, those are our requirements.</p> <h2 data-svelte-h="svelte-1ejphaj"><a href="#high-level-design">High level design</a><span id="high-level-design"></span></h2> <p data-svelte-h="svelte-poosnr">So, what are the basics for a high level design?</p> <p data-svelte-h="svelte-li0lgm">Well, basically:</p> <ul data-svelte-h="svelte-1x2l5j6"><li>The sender sends a message</li> <li>Chat service handles it, saves to database</li> <li>Chat service pushes the message to receiver</li></ul> <p data-svelte-h="svelte-9hmuex">Now, in here, we’ll explore another network protocol. So far, we’ve been working with <a href="https://www.cloudflare.com/en-gb/learning/ddos/glossary/hypertext-transfer-protocol-http/" rel="nofollow">HTTP</a>.</p> <p data-svelte-h="svelte-v9lni">However, if we’d read the definition more closely:</p> <blockquote data-svelte-h="svelte-w2g3mb"><p>A typical flow over HTTP involves a client machine making a request to a server, which then sends a response message</p></blockquote> <p data-svelte-h="svelte-161708q">Now, that’s important! A client requests to a server! We don’t want that with a chat application.</p> <p data-svelte-h="svelte-r2uf09">Or we might! If we’d want that, we’d could go with <a href="https://stackoverflow.com/questions/4642598/short-polling-vs-long-polling-for-real-time-web-applications" rel="nofollow">polling</a></p> <ul data-svelte-h="svelte-1lwidpl"><li>Short polling is asking often</li> <li>Long polling is asking less often</li></ul> <p data-svelte-h="svelte-154hdfa">Now, those are very vague descriptions. Let me quote the SO post:</p> <p data-svelte-h="svelte-o22mfv">Short polling:</p> <pre class="language-undefined"><!-- HTML_TAG_START -->${`<code class="language-undefined">00:00:00 C-&gt; Is the cake ready? 
00:00:01 S-&gt; No, wait.
00:00:01 C-&gt; Is the cake ready?
00:00:02 S-&gt; No, wait.
00:00:02 C-&gt; Is the cake ready? 
00:00:03 S-&gt; Yes. Have some lad.
00:00:03 C-&gt; Is the other cake ready? ..</code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1xefn6p">Long polling:</p> <pre class="language-undefined"><!-- HTML_TAG_START -->${`<code class="language-undefined">12:00 00:00:00 C-&gt; Is the cake ready? 
12:00 00:00:03 S-&gt; Yes.Have some lad.
12:00 00:00:03 C-&gt; Is the cake ready? </code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1kf2m60">Specifically, note the timestamps.</p> <p data-svelte-h="svelte-14ukgc6">But, let’s say we don’t want to use polling. Well, with HTTP, we have no other reasonable way to create a chat.
In come <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="nofollow">WebSockets</a>.</p> <p data-svelte-h="svelte-15vj44e">Now, with websockets, or <strong>ws</strong> for short, where only the initial call is HTTP, but all other ws calls are actually messages
using a persistent connection. <a href="https://en.wikipedia.org/wiki/SignalR" rel="nofollow">SignalR</a> or <a href="https://socket.io/" rel="nofollow">Socket.IO</a> are popular adopters.</p> <p data-svelte-h="svelte-5lpast">So, we can finally consider our system:</p> <ul data-svelte-h="svelte-p4ax7s"><li>We’ll have a user</li> <li>We have a lot of users -&gt; Multiple servers -&gt; Load balancer</li> <li>We want to have users. Therefore, we also want authentication<ul><li>We will have some services working purely on HTTP</li></ul></li> <li>Finally, we will have a chat service<ul><li>Connects to users as well</li> <li>Is stateful, imn contrast to other ones</li></ul></li> <li>Finally, push notifications will be tackled by third party tooling.</li></ul> <p data-svelte-h="svelte-la2teu">Now, since there is no heavy lifting done on the regular servers, we <strong>COULD</strong> fit them all into one server.
However, as was mentioned multiple times, single server means single point of failure. Therefore, as always, we’ll
put them behind a load balancer.</p> <p data-svelte-h="svelte-nj5bo9">Now, finally, it could look something like this:</p> <img src="/images/system-design/chat-service.webp" alt="Chat Service" title="Chat Service" class="image" loading="lazy"> <ul data-svelte-h="svelte-15yb8gj"><li>We’ll have notification that handles PN to users, which will be triggered by API servers</li> <li>We’ll have API servers that handle authentication and initial services</li> <li>Finally, we’ll have <strong>real time service</strong> that contains the chat servers, as well as online presence.</li></ul> <p data-svelte-h="svelte-1gdc81z">All the data will be stored in key-value stores, as they are very solid choice for massive amounts of data.</p> <p data-svelte-h="svelte-phs0a8">Let’s hang with storage a little longer though. We’ve mentioned a lot of daily active users. Furthermore, we want it to be
stored forever. Now, that’s a long time, isn’t it?</p> <p data-svelte-h="svelte-2wfapp">Well, let’s look at statistics. <a href="https://www.theverge.com/2016/4/12/11415198/facebook-messenger-whatsapp-number-messages-vs-sms-f8-2016" rel="nofollow">Messenger and WhatsApp process 60 billions messages per day</a>.
That’s A LOT. Imagine that you’re saving unicode characters (2 bytes in size) with that.</p> <ul data-svelte-h="svelte-rcasp1"><li>60 billions ~= 60 GB * 2 ~= 120 GB storage daily per character</li> <li>If the characters can be 100k chars long, that’d be 120 * 100.000 ~= 12 petabytes</li></ul> <p data-svelte-h="svelte-qg4jki">Now, of course, we’ve all used messages. We can easily send twenty 3-char messages per minute. But it’s a lot of space.</p> <p data-svelte-h="svelte-1eb0vw0">So, all in all, we have to account for A LOT of storage space. How would we do that?</p> <p data-svelte-h="svelte-6txxvq">Well, again, we need to know how the data will be handled. Looking at how I recently worked with chats:</p> <ul data-svelte-h="svelte-189cewc"><li>Older messages are very rarely read, BUT we must support searching in history</li> <li>In general, we must support multiple searches - mentions, jumping to specific messages, …</li> <li>Read to write ratio is around 1:1</li></ul> <p data-svelte-h="svelte-w6i0ad">Because of that, key value stores are a really solid choice!</p> <ul data-svelte-h="svelte-190vign"><li>Easy to scale horizontally</li> <li>Low latency to access data</li> <li>Popular chats use these<ul><li><a href="https://research.facebook.com/publications/storage-infrastructure-behind-facebook-messages-using-hbase-at-scale/" rel="nofollow">FB uses HBase</a></li> <li><a href="https://discord.com/blog/how-discord-stores-trillions-of-messages" rel="nofollow">Discord uses Cassandra</a></li></ul></li></ul> <p data-svelte-h="svelte-10cv27s">So, finally, the data model could look something like:</p> <pre class="language-json"><!-- HTML_TAG_START -->${`<code class="language-json"><span class="token punctuation">&#123;</span>
  message_id<span class="token operator">:</span> <span class="token string">"number"</span>;
  message_from<span class="token operator">:</span> <span class="token string">"number"</span>;
  message_to<span class="token operator">:</span> <span class="token string">"number"</span>;
  content<span class="token operator">:</span> <span class="token string">"string"</span>;
  created_at<span class="token operator">:</span> <span class="token string">"timestamp"</span>;
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-n9a7ll">Now, in designing a unique ID generator, we’d probably reuse that. However, there can be quite a lot of messages created at one time with
chats. Therefore, we’ll have ID that also works as sequence number.</p> <p data-svelte-h="svelte-1sh6yh1">With group messages, it’d be pretty much the same. The main difference here would be <code>message_to</code> being a channel ID. It would look something like:</p> <pre class="language-json"><!-- HTML_TAG_START -->${`<code class="language-json"><span class="token punctuation">&#123;</span>
  message_id<span class="token operator">:</span> <span class="token string">"number"</span>;
  user_id<span class="token operator">:</span> <span class="token string">"number"</span>;
  channel_id<span class="token operator">:</span> <span class="token string">"number"</span>;
  content<span class="token operator">:</span> <span class="token string">"string"</span>;
  created_at<span class="token operator">:</span> <span class="token string">"timestamp"</span>;
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-azhfb2">Finally, how’d the message ID look like?</p> <p data-svelte-h="svelte-p9gel2">I’ve mentioned multiple times that autoIncrement is insufficient because of scaling. However, this is a very specific case where it actually
may be good enough! Kind of. Key value stores dont have autoincrement.</p> <p data-svelte-h="svelte-1cr83bb">So, we’d use a local unique ID generation. Which could work very similar - we’d just have to generate it ourselves. Now, why would it work here?
Because users are already part of some channels. So the IDs need to be unique only within the context of the data. If you have a message between
user A and user B, then if the <code>id</code> clashes with a message between user B and user C, it’s not an issue. You can still identify it!</p> <p data-svelte-h="svelte-1q2szbb">Nonetheless, it is still possible to create our own unique distributed ID for this as well.</p> <h2 data-svelte-h="svelte-s73peb"><a href="#requirements">Deep dive</a><span id="requirements"></span></h2> <p data-svelte-h="svelte-1xe98g4">So, we’ve established how our storage works, what’s being used, how chats work. Now, one of the things I mentioned is that
we are using websockets to connect to chat server. However, WHAT chat server? Remember, there will probably be a lot of them.</p> <p data-svelte-h="svelte-1mwod2o">So, how would we connect 2 users to a specific server? Well, we’ll have to use what’s called a <code>Service Discovery</code>.
<a href="https://zookeeper.apache.org/" rel="nofollow">Apache ZooKeeper</a> is a popular open source that we can use. From description:</p> <blockquote data-svelte-h="svelte-1rmjxsn"><p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services</p></blockquote> <p data-svelte-h="svelte-ydoie7">The flow would then look like:</p> <ul data-svelte-h="svelte-6w8vdc"><li>A user logs into the app</li> <li>Load balancer forwards it to API servers</li> <li>API server does authentication and other thingies, then finds the best chat service</li> <li>The chat service to be used is returned to user, and user finally connects to specific server through websocket.</li></ul> <h3 data-svelte-h="svelte-1oacvyk"><a href="#1-on-1">Direct messages</a><span id="1-on-1"></span></h3> <p data-svelte-h="svelte-16szag9">So, provided that user is already on the chat server, the following happens:</p> <ul data-svelte-h="svelte-11fb1v8"><li><strong>user A</strong> sends a chat message to <strong>chat server 1</strong></li> <li><strong>chat server 1</strong> obtains the message ID from generator and adds it to a message queue</li> <li>Message queue stores it into key-value store and forward it to:<ul><li>If user is online, the message is forwarded to <strong>server</strong> where <strong>user B</strong> is connected<ul><li><strong>server</strong> forwards the message to <strong>user B</strong> through WebSocket</li></ul></li> <li>If user is offline, the message is sent as a notification. On next app load, the user will fetch it with other messages</li></ul></li></ul> <img src="/images/system-design/direct-message-flow.webp" alt="Direct Messages" title="Direct Messages" class="image" loading="lazy"> <p data-svelte-h="svelte-1o01z4q">Now, the potential problem here is synchronization between multiple devices. Imagine you’re on Facebook and you’re logged on your
desktop and mobile simultaneously.</p> <p data-svelte-h="svelte-1xpfgd6">To achieve some synchronization in here. we might keep track of latest message ID. How’d that work?</p> <p data-svelte-h="svelte-qz4p2u">Well, we’d have something like:</p> <ul data-svelte-h="svelte-1pr41vq"><li>The message is sent to a recipient, who is always the <code>user_id</code></li> <li>The client will keep track of <code>last_message_id</code></li> <li>If <code>last_message_id</code> is lower than new message in KV store, then new messages are fetched</li></ul> <img src="/images/system-design/multiple-devices-sync.webp" alt="Multiple Devices" title="Multiple Devices" class="image" loading="lazy"> <h3 data-svelte-h="svelte-ou3rhf"><a href="#group">Group chats</a><span id="group"></span></h3> <p data-svelte-h="svelte-d18w2v">Group chats are a little more complicated. We can view them as direct messages, except the message is sent to multiple users. So how would that work?</p> <p data-svelte-h="svelte-1l5oac6">Well, first, we need to understand that when we sent a message, we basically send it to multiple users. So, we could take the design from before</p> <p data-svelte-h="svelte-104f0zy">Consider the previous design. What do we need to add a user? Well, we’ll just another link from message queue to another chat server.</p> <p data-svelte-h="svelte-1l6saly">We could do that, and that would work. However, if we want to be a little more scalable, we could add more message queues. We could have a message queue for each user connected to the chat server</p> <p data-svelte-h="svelte-mym21r">That’d be beneficial for two reasons:</p> <ul data-svelte-h="svelte-1er0f88"><li>When messages are outgoing, they will go one by one to the end user</li> <li>When the messages are incoming (read: I logged in and have 20 different messages from multiple people), then I’d just load my own messages easier</li></ul> <p data-svelte-h="svelte-1igkxxc">So, the final flow could be like:</p> <p data-svelte-h="svelte-pfliuf"><strong>sending messages</strong></p> <img src="/images/system-design/sender-messages.webp" alt="Sending message" title="Sending message" class="image" loading="lazy"> <p data-svelte-h="svelte-1t2kv07"><strong>receiving messages</strong></p> <img src="/images/system-design/receiver-messages.webp" alt="Receiving message" title="Receiving message" class="image" loading="lazy"> <h2 data-svelte-h="svelte-7l2p8v"><a href="#requirements">Online presence</a><span id="requirements"></span></h2> <p data-svelte-h="svelte-106od67">Now, the last problem we need to deal with is online presence. An indicator is often shown - a green dot if a user is online, for example.</p> <p data-svelte-h="svelte-b6dfef">How would that work? Well, let’s first think about how we could do that.</p> <ul data-svelte-h="svelte-cg5kbv"><li>We need to keep track if user is online or not</li> <li>Client sends heartbeat requests to server every N seconds</li> <li>If a client did not respond for M seconds, he is considered offline</li> <li>When users logs out or logs in, he’d start or stop sending the requests, solving that as well.</li> <li>When user disconnects because of connection termination, these requests don’t happen, so it works for this.</li></ul> <p data-svelte-h="svelte-1ltypbs">So, that’s a lot of requests. To not slow down our regular servers, let’s have some <strong>Presence services</strong>.</p> <p data-svelte-h="svelte-1r9cq2s">Finally, users would be subscribed to message queues on these servers, depending on whether those are group chats or not</p> <h2 data-svelte-h="svelte-1gat2or"><a href="#summary">Summary</a><span id="summary"></span></h2> <p data-svelte-h="svelte-rgrw1a">So, here we are again! At the end of the road for chat service. Let’s look at what we’ve learned and how we’ve designed it. Going back:</p> <ul data-svelte-h="svelte-1h307q2"><li>1-to-1 and group chat</li> <li>mobile &amp; web app</li> <li>50 millions daily active users</li> <li>online indicator is available</li> <li>Message has a size limit of 100 000 characters</li> <li>End to end encryption is supported</li> <li>The chat history should be stored forever</li></ul> <p data-svelte-h="svelte-1o4uyzf">So, how did we do?</p> <ul data-svelte-h="svelte-8isjeg"><li>The 1-to-1 and group chat designs were created</li> <li>Mobile &amp; Web app were tackled with synchronization</li> <li>50 millions DAU are handled by multiple servers, KV stores and websockets</li> <li>Online indicator via heartbeat</li> <li>Message limit is basically storage limit - We’ve used suitable storage component</li> <li>Chat history should be stored forever -&gt; KV stores are easily scaled horizontally</li> <li>End to End encryption was not discussed</li></ul> <p data-svelte-h="svelte-9do9et">So, we are missing one thing. So let’s have a quick look at that!</p> <p data-svelte-h="svelte-1y29xrs">End to end encryption basically means - we as a provider can’t read messages. So, what would happen is we basically need to encrypt the data:</p> <ul data-svelte-h="svelte-gpgr1j"><li>Private and Public key of each user</li> <li>Public keys are stored on server to hash the message</li> <li>Private keys are used on client to decrypt the message</li></ul> <p data-svelte-h="svelte-1x5ak50">Now, with group chats, that’s a little more complicated. We have a <a href="https://security.stackexchange.com/questions/126768/which-protocols-exist-for-end-to-end-encrypted-group-chat" rel="nofollow">lot of options</a>.</p> <p data-svelte-h="svelte-ctl1tp">One we could use is just PGP. The gist of it is:</p> <ul data-svelte-h="svelte-15uatyr"><li>Generate a key and use it to hash text</li> <li>Hash this key using public key of recipients</li> <li>Send hashed key to recipients</li> <li>Each client would then first decrypt the hashed key</li> <li>Then with decrypted key, he’d decrypt his message</li> <li>Finally, he can read the message</li></ul> <p data-svelte-h="svelte-1xvqsjr">And that’s it! We’ve created a chat system!</p> <h1 data-svelte-h="svelte-uqufyh"><a href="#references">References</a><span id="references"></span></h1> <ul data-svelte-h="svelte-c2viyc"><li><a href="https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF" rel="nofollow">System Design Interview book</a></li> <li><a href="https://bytebytego.com/courses/system-design-interview/design-a-chat-system" rel="nofollow">Design a Chat System</a></li> <li><a href="https://www.cloudflare.com/en-gb/learning/ddos/glossary/hypertext-transfer-protocol-http/" rel="nofollow">HTTP</a></li> <li><a href="https://stackoverflow.com/questions/4642598/short-polling-vs-long-polling-for-real-time-web-applications" rel="nofollow">Polling</a></li> <li><a href="https://en.wikipedia.org/wiki/SignalR" rel="nofollow">SignalR</a></li> <li><a href="https://socket.io/" rel="nofollow">Socket.IO</a></li> <li><a href="https://www.theverge.com/2016/4/12/11415198/facebook-messenger-whatsapp-number-messages-vs-sms-f8-2016" rel="nofollow">Messenger and WhatsApp process 60 billions messages per day</a></li> <li><a href="https://research.facebook.com/publications/storage-infrastructure-behind-facebook-messages-using-hbase-at-scale/" rel="nofollow">FB uses HBase</a></li> <li><a href="https://discord.com/blog/how-discord-stores-trillions-of-messages" rel="nofollow">Discord uses Cassandra</a></li> <li><a href="https://security.stackexchange.com/questions/126768/which-protocols-exist-for-end-to-end-encrypted-group-chat" rel="nofollow">E2E of group messages</a></li></ul>`;
});
export {
  _10_system_design_chat_service as default
};
